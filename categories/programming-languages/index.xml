<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming Languages on Shengting Cao&#39;s Note Book</title>
    <link>https://shengtingcao.top/categories/programming-languages/</link>
    <description>Recent content in Programming Languages on Shengting Cao&#39;s Note Book</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 26 Feb 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://shengtingcao.top/categories/programming-languages/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Programming Language Design</title>
      <link>https://shengtingcao.top/blog/proglangdesignenv/</link>
      <pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://shengtingcao.top/blog/proglangdesignenv/</guid>
      <description>Problem Description The environment is a tree to store all the value we need for future use. In the environment file it will have five basic functions
 create extend lookup insert update  functions function define  extern Lexeme *createEnv(); extern Lexeme *extendEnv(Lexeme *env, Lexeme *vars, Lexeme *vals); extern Lexeme *makeTable(Lexeme *vars, Lexeme *vals); extern Lexeme *lookupEnv(Lexeme *var, Lexeme *env); extern int sameVariable(Lexeme *x, Lexeme *y); extern Lexeme *insert(Lexeme *var, Lexeme *val, Lexeme *env); extern Lexeme *updateEnv(Lexeme *var, Lexeme *env, Lexeme *newVariable);  create environment  Lexeme *createEnv() { return extendEnv(NULL, NULL, NULL); }  extend environment  Lexeme *extendEnv(Lexeme *env, Lexeme *vars, Lexeme *vals) { return cons(ENVIRONMENT, makeTable(vars, vals), env); }  make table  Lexeme *makeTable(Lexeme *vars, Lexeme *vals) { return cons(TABLE, vars, vals); }  lookup environment  Lexeme *lookupEnv(Lexeme *var, Lexeme *env) { while (env !</description>
    </item>
    
    <item>
      <title>Programming language design</title>
      <link>https://shengtingcao.top/blog/proglangdesignlexical/</link>
      <pubDate>Thu, 07 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://shengtingcao.top/blog/proglangdesignlexical/</guid>
      <description>Problem Description When implementing a programming language, the first step is reading in the source code of a program written in that language. Typically, the source code is stored as a file of characters. To read in a source code file, one groups the important individual characters into tokens and discards the unimportant characters. For example, consider the Python program:
print &#39;Hello World!&#39;  There are two tokens in this program, print and &amp;lsquo;Hello World!</description>
    </item>
    
    <item>
      <title>Programming Language Design</title>
      <link>https://shengtingcao.top/blog/programminglanguagedesigngrammar/</link>
      <pubDate>Fri, 25 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://shengtingcao.top/blog/programminglanguagedesigngrammar/</guid>
      <description>Problem Description The task is to build an interpreter for a general purpose programming language of my own design. The language must - support the following features:
 comments integers and strings dynamically typed (like Scheme and Python) classes/objects arrays with O(1) access time conditionals recursion iteration convenient means to access command line arguments convenient means to print to the console convenient means to read integers from a file an adequate set of operators anonymous functions functions as first-class objects (i.</description>
    </item>
    
  </channel>
</rss>